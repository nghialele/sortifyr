// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlist.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const playlistCreate = `-- name: PlaylistCreate :one
INSERT INTO playlists (user_id, spotify_id, owner_uid, name, description, public, track_amount, collaborative, cover_id, cover_url)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id
`

type PlaylistCreateParams struct {
	UserID        int32
	SpotifyID     string
	OwnerUid      string
	Name          string
	Description   pgtype.Text
	Public        bool
	TrackAmount   int32
	Collaborative bool
	CoverID       pgtype.Text
	CoverUrl      pgtype.Text
}

func (q *Queries) PlaylistCreate(ctx context.Context, arg PlaylistCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, playlistCreate,
		arg.UserID,
		arg.SpotifyID,
		arg.OwnerUid,
		arg.Name,
		arg.Description,
		arg.Public,
		arg.TrackAmount,
		arg.Collaborative,
		arg.CoverID,
		arg.CoverUrl,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const playlistDelete = `-- name: PlaylistDelete :exec
DELETE FROM playlists
WHERE id = $1
`

func (q *Queries) PlaylistDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, playlistDelete, id)
	return err
}

const playlistGet = `-- name: PlaylistGet :one
SELECT id, user_id, spotify_id, owner_uid, name, description, public, track_amount, collaborative, cover_id, cover_url
FROM playlists
WHERE id = $1
`

func (q *Queries) PlaylistGet(ctx context.Context, id int32) (Playlist, error) {
	row := q.db.QueryRow(ctx, playlistGet, id)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SpotifyID,
		&i.OwnerUid,
		&i.Name,
		&i.Description,
		&i.Public,
		&i.TrackAmount,
		&i.Collaborative,
		&i.CoverID,
		&i.CoverUrl,
	)
	return i, err
}

const playlistGetByUserWithOwner = `-- name: PlaylistGetByUserWithOwner :many
SELECT p.id, p.user_id, p.spotify_id, p.owner_uid, p.name, p.description, p.public, p.track_amount, p.collaborative, p.cover_id, p.cover_url, u.id, u.uid, u.name, u.display_name, u.email
FROM playlists p
LEFT JOIN users u ON u.uid = p.owner_uid
WHERE p.user_id = $1
ORDER BY p.name
`

type PlaylistGetByUserWithOwnerRow struct {
	Playlist Playlist
	User     User
}

func (q *Queries) PlaylistGetByUserWithOwner(ctx context.Context, userID int32) ([]PlaylistGetByUserWithOwnerRow, error) {
	rows, err := q.db.Query(ctx, playlistGetByUserWithOwner, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlaylistGetByUserWithOwnerRow
	for rows.Next() {
		var i PlaylistGetByUserWithOwnerRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.UserID,
			&i.Playlist.SpotifyID,
			&i.Playlist.OwnerUid,
			&i.Playlist.Name,
			&i.Playlist.Description,
			&i.Playlist.Public,
			&i.Playlist.TrackAmount,
			&i.Playlist.Collaborative,
			&i.Playlist.CoverID,
			&i.Playlist.CoverUrl,
			&i.User.ID,
			&i.User.Uid,
			&i.User.Name,
			&i.User.DisplayName,
			&i.User.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playlistUpdateBySpotify = `-- name: PlaylistUpdateBySpotify :exec
UPDATE playlists
SET owner_uid = $2, name = $3, description = $4, public = $5, track_amount = $6, collaborative = $7, cover_id = $8, cover_url = $9
WHERE spotify_id = $1
`

type PlaylistUpdateBySpotifyParams struct {
	SpotifyID     string
	OwnerUid      string
	Name          string
	Description   pgtype.Text
	Public        bool
	TrackAmount   int32
	Collaborative bool
	CoverID       pgtype.Text
	CoverUrl      pgtype.Text
}

func (q *Queries) PlaylistUpdateBySpotify(ctx context.Context, arg PlaylistUpdateBySpotifyParams) error {
	_, err := q.db.Exec(ctx, playlistUpdateBySpotify,
		arg.SpotifyID,
		arg.OwnerUid,
		arg.Name,
		arg.Description,
		arg.Public,
		arg.TrackAmount,
		arg.Collaborative,
		arg.CoverID,
		arg.CoverUrl,
	)
	return err
}
