// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: playlist.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const playlistCreate = `-- name: PlaylistCreate :one
INSERT INTO playlists (spotify_id, owner_id, name, description, public, track_amount, collaborative, cover_id, cover_url, snapshot_id)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id
`

type PlaylistCreateParams struct {
	SpotifyID     string
	OwnerID       pgtype.Int4
	Name          pgtype.Text
	Description   pgtype.Text
	Public        pgtype.Bool
	TrackAmount   pgtype.Int4
	Collaborative pgtype.Bool
	CoverID       pgtype.Text
	CoverUrl      pgtype.Text
	SnapshotID    pgtype.Text
}

func (q *Queries) PlaylistCreate(ctx context.Context, arg PlaylistCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, playlistCreate,
		arg.SpotifyID,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Public,
		arg.TrackAmount,
		arg.Collaborative,
		arg.CoverID,
		arg.CoverUrl,
		arg.SnapshotID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const playlistGet = `-- name: PlaylistGet :one
SELECT id, spotify_id, name, description, public, track_amount, collaborative, cover_id, cover_url, owner_id, updated_at, snapshot_id
FROM playlists
WHERE id = $1
`

func (q *Queries) PlaylistGet(ctx context.Context, id int32) (Playlist, error) {
	row := q.db.QueryRow(ctx, playlistGet, id)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.SpotifyID,
		&i.Name,
		&i.Description,
		&i.Public,
		&i.TrackAmount,
		&i.Collaborative,
		&i.CoverID,
		&i.CoverUrl,
		&i.OwnerID,
		&i.UpdatedAt,
		&i.SnapshotID,
	)
	return i, err
}

const playlistGetBySpotify = `-- name: PlaylistGetBySpotify :one
SELECT id, spotify_id, name, description, public, track_amount, collaborative, cover_id, cover_url, owner_id, updated_at, snapshot_id
FROM playlists
WHERE spotify_id = $1
`

func (q *Queries) PlaylistGetBySpotify(ctx context.Context, spotifyID string) (Playlist, error) {
	row := q.db.QueryRow(ctx, playlistGetBySpotify, spotifyID)
	var i Playlist
	err := row.Scan(
		&i.ID,
		&i.SpotifyID,
		&i.Name,
		&i.Description,
		&i.Public,
		&i.TrackAmount,
		&i.Collaborative,
		&i.CoverID,
		&i.CoverUrl,
		&i.OwnerID,
		&i.UpdatedAt,
		&i.SnapshotID,
	)
	return i, err
}

const playlistGetByUser = `-- name: PlaylistGetByUser :many
SELECT p.id, p.spotify_id, p.name, p.description, p.public, p.track_amount, p.collaborative, p.cover_id, p.cover_url, p.owner_id, p.updated_at, p.snapshot_id
FROM playlists p
LEFT JOIN playlist_users pu ON pu.playlist_id = p.id
WHERE pu.user_id = $1 AND pu.deleted_at IS NULL
ORDER BY p.name
`

func (q *Queries) PlaylistGetByUser(ctx context.Context, userID int32) ([]Playlist, error) {
	rows, err := q.db.Query(ctx, playlistGetByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Playlist
	for rows.Next() {
		var i Playlist
		if err := rows.Scan(
			&i.ID,
			&i.SpotifyID,
			&i.Name,
			&i.Description,
			&i.Public,
			&i.TrackAmount,
			&i.Collaborative,
			&i.CoverID,
			&i.CoverUrl,
			&i.OwnerID,
			&i.UpdatedAt,
			&i.SnapshotID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playlistGetByUserWithOwner = `-- name: PlaylistGetByUserWithOwner :many
SELECT p.id, p.spotify_id, p.name, p.description, p.public, p.track_amount, p.collaborative, p.cover_id, p.cover_url, p.owner_id, p.updated_at, p.snapshot_id, u.id, u.uid, u.name, u.display_name, u.email
FROM playlists p
LEFT JOIN playlist_users pu ON pu.playlist_id = p.id
LEFT JOIN users u ON u.id = p.owner_id
WHERE pu.user_id = $1 AND p.owner_id IS NOT NULL AND pu.deleted_at IS NULL
ORDER BY p.name
`

type PlaylistGetByUserWithOwnerRow struct {
	Playlist Playlist
	User     User
}

func (q *Queries) PlaylistGetByUserWithOwner(ctx context.Context, userID int32) ([]PlaylistGetByUserWithOwnerRow, error) {
	rows, err := q.db.Query(ctx, playlistGetByUserWithOwner, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlaylistGetByUserWithOwnerRow
	for rows.Next() {
		var i PlaylistGetByUserWithOwnerRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.SpotifyID,
			&i.Playlist.Name,
			&i.Playlist.Description,
			&i.Playlist.Public,
			&i.Playlist.TrackAmount,
			&i.Playlist.Collaborative,
			&i.Playlist.CoverID,
			&i.Playlist.CoverUrl,
			&i.Playlist.OwnerID,
			&i.Playlist.UpdatedAt,
			&i.Playlist.SnapshotID,
			&i.User.ID,
			&i.User.Uid,
			&i.User.Name,
			&i.User.DisplayName,
			&i.User.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playlistGetDuplicateTracksByUser = `-- name: PlaylistGetDuplicateTracksByUser :many
SELECT p.id, p.spotify_id, p.name, p.description, p.public, p.track_amount, p.collaborative, p.cover_id, p.cover_url, p.owner_id, p.updated_at, p.snapshot_id, t.id, t.spotify_id, t.name, t.popularity, t.updated_at, u.id, u.uid, u.name, u.display_name, u.email
FROM playlist_tracks pt
JOIN (
  SELECT playlist_id, track_id
  FROM playlist_tracks
  WHERE deleted_at IS NULL
  GROUP BY playlist_id, track_id
  HAVING COUNT(*) > 1
) dup
ON dup.playlist_id = pt.playlist_id
AND dup.track_id = pt.track_id
LEFT JOIN playlists p ON p.id = pt.playlist_id
LEFT JOIN tracks t ON t.id = pt.track_id
LEFT JOIN playlist_users pu ON pu.playlist_id = p.id
LEFT JOIN users u ON u.id = p.owner_id
WHERE pu.user_id = $1 AND p.owner_id IS NOT NULL AND pu.deleted_at IS NULL
ORDER BY pt.playlist_id, pt.track_id, pt.id
`

type PlaylistGetDuplicateTracksByUserRow struct {
	Playlist Playlist
	Track    Track
	User     User
}

func (q *Queries) PlaylistGetDuplicateTracksByUser(ctx context.Context, userID int32) ([]PlaylistGetDuplicateTracksByUserRow, error) {
	rows, err := q.db.Query(ctx, playlistGetDuplicateTracksByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlaylistGetDuplicateTracksByUserRow
	for rows.Next() {
		var i PlaylistGetDuplicateTracksByUserRow
		if err := rows.Scan(
			&i.Playlist.ID,
			&i.Playlist.SpotifyID,
			&i.Playlist.Name,
			&i.Playlist.Description,
			&i.Playlist.Public,
			&i.Playlist.TrackAmount,
			&i.Playlist.Collaborative,
			&i.Playlist.CoverID,
			&i.Playlist.CoverUrl,
			&i.Playlist.OwnerID,
			&i.Playlist.UpdatedAt,
			&i.Playlist.SnapshotID,
			&i.Track.ID,
			&i.Track.SpotifyID,
			&i.Track.Name,
			&i.Track.Popularity,
			&i.Track.UpdatedAt,
			&i.User.ID,
			&i.User.Uid,
			&i.User.Name,
			&i.User.DisplayName,
			&i.User.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playlistUpdateBySpotify = `-- name: PlaylistUpdateBySpotify :exec
UPDATE playlists
SET 
  owner_id = coalesce($2, owner_id),
  name = coalesce($3, name),
  description = coalesce($4, description),
  public = coalesce($5, public),
  track_amount = coalesce($6, track_amount),
  collaborative = coalesce($7, collaborative),
  cover_id = coalesce($8, cover_id),
  cover_url = coalesce($9, cover_url),
  snapshot_id = coalesce($10, snapshot_id),
  updated_at = NOW()
WHERE spotify_id = $1
`

type PlaylistUpdateBySpotifyParams struct {
	SpotifyID     string
	OwnerID       pgtype.Int4
	Name          pgtype.Text
	Description   pgtype.Text
	Public        pgtype.Bool
	TrackAmount   pgtype.Int4
	Collaborative pgtype.Bool
	CoverID       pgtype.Text
	CoverUrl      pgtype.Text
	SnapshotID    pgtype.Text
}

func (q *Queries) PlaylistUpdateBySpotify(ctx context.Context, arg PlaylistUpdateBySpotifyParams) error {
	_, err := q.db.Exec(ctx, playlistUpdateBySpotify,
		arg.SpotifyID,
		arg.OwnerID,
		arg.Name,
		arg.Description,
		arg.Public,
		arg.TrackAmount,
		arg.Collaborative,
		arg.CoverID,
		arg.CoverUrl,
		arg.SnapshotID,
	)
	return err
}
