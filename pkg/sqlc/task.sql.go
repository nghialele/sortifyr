// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task.sql

package sqlc

import (
	"context"
)

const taskCreate = `-- name: TaskCreate :exec
INSERT INTO tasks (uid, name, active)
VALUES ($1, $2, $3)
`

type TaskCreateParams struct {
	Uid    string
	Name   string
	Active bool
}

func (q *Queries) TaskCreate(ctx context.Context, arg TaskCreateParams) error {
	_, err := q.db.Exec(ctx, taskCreate, arg.Uid, arg.Name, arg.Active)
	return err
}

const taskGetByUID = `-- name: TaskGetByUID :one
SELECT uid, name, active
FROM tasks
WHERE uid = $1
`

func (q *Queries) TaskGetByUID(ctx context.Context, uid string) (Task, error) {
	row := q.db.QueryRow(ctx, taskGetByUID, uid)
	var i Task
	err := row.Scan(&i.Uid, &i.Name, &i.Active)
	return i, err
}

const taskGetFiltered = `-- name: TaskGetFiltered :many
SELECT t.uid, t.name, t.active, r.id, r.task_uid, r.user_id, r.run_at, r.result, r.message, r.error, r.duration
FROM task_runs r
LEFT JOIN tasks t ON t.uid = r.task_uid
WHERE
  (r.user_id = $1::int OR r.user_id IS NULL) AND
  (t.uid = $2 OR NOT $6) AND
  (r.result = $3 OR NOT $7) AND
  t.active
ORDER BY r.run_at DESC
LIMIT $4 OFFSET $5
`

type TaskGetFilteredParams struct {
	Column1       int32
	Uid           string
	Result        TaskResult
	Limit         int32
	Offset        int32
	FilterTaskUid interface{}
	FilterResult  interface{}
}

type TaskGetFilteredRow struct {
	Task    Task
	TaskRun TaskRun
}

func (q *Queries) TaskGetFiltered(ctx context.Context, arg TaskGetFilteredParams) ([]TaskGetFilteredRow, error) {
	rows, err := q.db.Query(ctx, taskGetFiltered,
		arg.Column1,
		arg.Uid,
		arg.Result,
		arg.Limit,
		arg.Offset,
		arg.FilterTaskUid,
		arg.FilterResult,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskGetFilteredRow
	for rows.Next() {
		var i TaskGetFilteredRow
		if err := rows.Scan(
			&i.Task.Uid,
			&i.Task.Name,
			&i.Task.Active,
			&i.TaskRun.ID,
			&i.TaskRun.TaskUid,
			&i.TaskRun.UserID,
			&i.TaskRun.RunAt,
			&i.TaskRun.Result,
			&i.TaskRun.Message,
			&i.TaskRun.Error,
			&i.TaskRun.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const taskRunGet = `-- name: TaskRunGet :one
SELECT t.uid, t.name, t.active, r.id, r.task_uid, r.user_id, r.run_at, r.result, r.message, r.error, r.duration
FROM task_runs r
LEFT JOIN tasks t ON t.uid = r.task_uid
WHERE r.id = $1
`

type TaskRunGetRow struct {
	Task    Task
	TaskRun TaskRun
}

func (q *Queries) TaskRunGet(ctx context.Context, id int32) (TaskRunGetRow, error) {
	row := q.db.QueryRow(ctx, taskRunGet, id)
	var i TaskRunGetRow
	err := row.Scan(
		&i.Task.Uid,
		&i.Task.Name,
		&i.Task.Active,
		&i.TaskRun.ID,
		&i.TaskRun.TaskUid,
		&i.TaskRun.UserID,
		&i.TaskRun.RunAt,
		&i.TaskRun.Result,
		&i.TaskRun.Message,
		&i.TaskRun.Error,
		&i.TaskRun.Duration,
	)
	return i, err
}

const taskSetInactiveAll = `-- name: TaskSetInactiveAll :exec
UPDATE tasks
SET active = false
`

func (q *Queries) TaskSetInactiveAll(ctx context.Context) error {
	_, err := q.db.Exec(ctx, taskSetInactiveAll)
	return err
}

const taskUpdate = `-- name: TaskUpdate :exec
UPDATE tasks
SET name = $2, active = $3
WHERE uid = $1
`

type TaskUpdateParams struct {
	Uid    string
	Name   string
	Active bool
}

func (q *Queries) TaskUpdate(ctx context.Context, arg TaskUpdateParams) error {
	_, err := q.db.Exec(ctx, taskUpdate, arg.Uid, arg.Name, arg.Active)
	return err
}
