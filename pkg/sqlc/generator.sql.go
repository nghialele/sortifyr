// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generator.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const generatorCreate = `-- name: GeneratorCreate :one
INSERT INTO generators (user_id, name, description, playlist_id, interval, spotify_outdated, parameters, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
RETURNING id
`

type GeneratorCreateParams struct {
	UserID          int32
	Name            string
	Description     pgtype.Text
	PlaylistID      pgtype.Int4
	Interval        pgtype.Int8
	SpotifyOutdated bool
	Parameters      []byte
}

func (q *Queries) GeneratorCreate(ctx context.Context, arg GeneratorCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, generatorCreate,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.PlaylistID,
		arg.Interval,
		arg.SpotifyOutdated,
		arg.Parameters,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const generatorDelete = `-- name: GeneratorDelete :exec
DELETE FROM generators
WHERE id = $1
`

func (q *Queries) GeneratorDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, generatorDelete, id)
	return err
}

const generatorGet = `-- name: GeneratorGet :one
SELECT id, user_id, name, description, playlist_id, interval, spotify_outdated, parameters, updated_at
FROM generators
WHERE id = $1
`

func (q *Queries) GeneratorGet(ctx context.Context, id int32) (Generator, error) {
	row := q.db.QueryRow(ctx, generatorGet, id)
	var i Generator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.PlaylistID,
		&i.Interval,
		&i.SpotifyOutdated,
		&i.Parameters,
		&i.UpdatedAt,
	)
	return i, err
}

const generatorGetAll = `-- name: GeneratorGetAll :many
SELECT id, user_id, name, description, playlist_id, interval, spotify_outdated, parameters, updated_at
FROM generators
`

func (q *Queries) GeneratorGetAll(ctx context.Context) ([]Generator, error) {
	rows, err := q.db.Query(ctx, generatorGetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Generator
	for rows.Next() {
		var i Generator
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.PlaylistID,
			&i.Interval,
			&i.SpotifyOutdated,
			&i.Parameters,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const generatorGetByUserPopulated = `-- name: GeneratorGetByUserPopulated :many
SELECT g.id, g.user_id, g.name, g.description, g.playlist_id, g.interval, g.spotify_outdated, g.parameters, g.updated_at, t.id, t.spotify_id, t.name, t.popularity, t.updated_at, t.duration_ms
FROM generators g
LEFT JOIN generator_tracks gt ON gt.generator_id = g.id
LEFT JOIN tracks t ON t.id = gt.track_id
WHERE g.user_id = $1
`

type GeneratorGetByUserPopulatedRow struct {
	Generator Generator
	Track     Track
}

func (q *Queries) GeneratorGetByUserPopulated(ctx context.Context, userID int32) ([]GeneratorGetByUserPopulatedRow, error) {
	rows, err := q.db.Query(ctx, generatorGetByUserPopulated, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeneratorGetByUserPopulatedRow
	for rows.Next() {
		var i GeneratorGetByUserPopulatedRow
		if err := rows.Scan(
			&i.Generator.ID,
			&i.Generator.UserID,
			&i.Generator.Name,
			&i.Generator.Description,
			&i.Generator.PlaylistID,
			&i.Generator.Interval,
			&i.Generator.SpotifyOutdated,
			&i.Generator.Parameters,
			&i.Generator.UpdatedAt,
			&i.Track.ID,
			&i.Track.SpotifyID,
			&i.Track.Name,
			&i.Track.Popularity,
			&i.Track.UpdatedAt,
			&i.Track.DurationMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const generatorUpdate = `-- name: GeneratorUpdate :exec
UPDATE generators
SET 
  name = coalesce($2, name),
  description = coalesce($3, description),
  playlist_id = coalesce($4, playlist_id),
  interval = coalesce($5, interval),
  spotify_outdated = coalesce($6, spotify_outdated),
  parameters = coalesce($7, parameters),
  updated_at = NOW()
WHERE id = $1
`

type GeneratorUpdateParams struct {
	ID              int32
	Name            pgtype.Text
	Description     pgtype.Text
	PlaylistID      pgtype.Int4
	Interval        pgtype.Int8
	SpotifyOutdated pgtype.Bool
	Parameters      []byte
}

func (q *Queries) GeneratorUpdate(ctx context.Context, arg GeneratorUpdateParams) error {
	_, err := q.db.Exec(ctx, generatorUpdate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.PlaylistID,
		arg.Interval,
		arg.SpotifyOutdated,
		arg.Parameters,
	)
	return err
}
