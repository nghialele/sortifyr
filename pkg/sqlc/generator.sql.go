// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generator.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const generatorCreate = `-- name: GeneratorCreate :one
INSERT INTO generators (user_id, name, description, playlist_id, interval, spotify_outdated, parameters, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
RETURNING id
`

type GeneratorCreateParams struct {
	UserID          int32
	Name            string
	Description     pgtype.Text
	PlaylistID      pgtype.Int4
	Interval        pgtype.Int8
	SpotifyOutdated bool
	Parameters      []byte
}

func (q *Queries) GeneratorCreate(ctx context.Context, arg GeneratorCreateParams) (int32, error) {
	row := q.db.QueryRow(ctx, generatorCreate,
		arg.UserID,
		arg.Name,
		arg.Description,
		arg.PlaylistID,
		arg.Interval,
		arg.SpotifyOutdated,
		arg.Parameters,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const generatorDelete = `-- name: GeneratorDelete :exec
DELETE FROM generators
WHERE id = $1
`

func (q *Queries) GeneratorDelete(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, generatorDelete, id)
	return err
}

const generatorGet = `-- name: GeneratorGet :one
SELECT id, user_id, name, description, playlist_id, interval, spotify_outdated, parameters, updated_at
FROM generators
WHERE id = $1
`

func (q *Queries) GeneratorGet(ctx context.Context, id int32) (Generator, error) {
	row := q.db.QueryRow(ctx, generatorGet, id)
	var i Generator
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.PlaylistID,
		&i.Interval,
		&i.SpotifyOutdated,
		&i.Parameters,
		&i.UpdatedAt,
	)
	return i, err
}

const generatorGetAll = `-- name: GeneratorGetAll :many
SELECT g.id, g.user_id, g.name, g.description, g.playlist_id, g.interval, g.spotify_outdated, g.parameters, g.updated_at, u.id, u.uid, u.name, u.display_name, u.email
FROM generators g
LEFT JOIN users u ON u.id = g.user_id
`

type GeneratorGetAllRow struct {
	Generator Generator
	User      User
}

func (q *Queries) GeneratorGetAll(ctx context.Context) ([]GeneratorGetAllRow, error) {
	rows, err := q.db.Query(ctx, generatorGetAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeneratorGetAllRow
	for rows.Next() {
		var i GeneratorGetAllRow
		if err := rows.Scan(
			&i.Generator.ID,
			&i.Generator.UserID,
			&i.Generator.Name,
			&i.Generator.Description,
			&i.Generator.PlaylistID,
			&i.Generator.Interval,
			&i.Generator.SpotifyOutdated,
			&i.Generator.Parameters,
			&i.Generator.UpdatedAt,
			&i.User.ID,
			&i.User.Uid,
			&i.User.Name,
			&i.User.DisplayName,
			&i.User.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const generatorGetByUserPopulated = `-- name: GeneratorGetByUserPopulated :many
SELECT
  g.id, g.user_id, g.name, g.description, g.playlist_id, g.interval, g.spotify_outdated, g.parameters, g.updated_at,
  COALESCE(json_agg(t.*) FILTER (WHERE t.id IS NOT NULL), '[]')::jsonb AS tracks
FROM generators g
LEFT JOIN generator_tracks gt ON gt.generator_id = g.id
LEFT JOIN tracks t ON t.id = gt.track_id
WHERE g.user_id = $1
GROUP BY g.id
`

type GeneratorGetByUserPopulatedRow struct {
	Generator Generator
	Tracks    []byte
}

func (q *Queries) GeneratorGetByUserPopulated(ctx context.Context, userID int32) ([]GeneratorGetByUserPopulatedRow, error) {
	rows, err := q.db.Query(ctx, generatorGetByUserPopulated, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GeneratorGetByUserPopulatedRow
	for rows.Next() {
		var i GeneratorGetByUserPopulatedRow
		if err := rows.Scan(
			&i.Generator.ID,
			&i.Generator.UserID,
			&i.Generator.Name,
			&i.Generator.Description,
			&i.Generator.PlaylistID,
			&i.Generator.Interval,
			&i.Generator.SpotifyOutdated,
			&i.Generator.Parameters,
			&i.Generator.UpdatedAt,
			&i.Tracks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const generatorUpdate = `-- name: GeneratorUpdate :exec
UPDATE generators
SET 
  name = coalesce($2, name),
  description = coalesce($3, description),
  playlist_id = $4,
  interval = coalesce($5, interval),
  spotify_outdated = coalesce($6, spotify_outdated),
  parameters = coalesce($7, parameters),
  updated_at = NOW()
WHERE id = $1
`

type GeneratorUpdateParams struct {
	ID              int32
	Name            pgtype.Text
	Description     pgtype.Text
	PlaylistID      pgtype.Int4
	Interval        pgtype.Int8
	SpotifyOutdated pgtype.Bool
	Parameters      []byte
}

func (q *Queries) GeneratorUpdate(ctx context.Context, arg GeneratorUpdateParams) error {
	_, err := q.db.Exec(ctx, generatorUpdate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.PlaylistID,
		arg.Interval,
		arg.SpotifyOutdated,
		arg.Parameters,
	)
	return err
}
